<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>笔记 | Jtf‘s Note</title>
    <meta name="description" content="生活杂记">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/note/img/favicon.ico">
    
    <link rel="preload" href="/note/assets/css/0.styles.27c4b003.css" as="style"><link rel="preload" href="/note/assets/js/app.105f0ca5.js" as="script"><link rel="preload" href="/note/assets/js/2.780ff301.js" as="script"><link rel="preload" href="/note/assets/js/7.e74d6790.js" as="script"><link rel="prefetch" href="/note/assets/js/10.d902dd7e.js"><link rel="prefetch" href="/note/assets/js/11.8b76e542.js"><link rel="prefetch" href="/note/assets/js/12.f0bb6086.js"><link rel="prefetch" href="/note/assets/js/13.1667f690.js"><link rel="prefetch" href="/note/assets/js/14.f92abac6.js"><link rel="prefetch" href="/note/assets/js/15.6b78ff81.js"><link rel="prefetch" href="/note/assets/js/16.79c20644.js"><link rel="prefetch" href="/note/assets/js/17.63f9acff.js"><link rel="prefetch" href="/note/assets/js/18.c438a82f.js"><link rel="prefetch" href="/note/assets/js/19.81040c50.js"><link rel="prefetch" href="/note/assets/js/20.96691558.js"><link rel="prefetch" href="/note/assets/js/21.e9e0a76a.js"><link rel="prefetch" href="/note/assets/js/22.1daf64e6.js"><link rel="prefetch" href="/note/assets/js/23.8fbb50c6.js"><link rel="prefetch" href="/note/assets/js/24.b47aab03.js"><link rel="prefetch" href="/note/assets/js/25.b62e1a13.js"><link rel="prefetch" href="/note/assets/js/26.0d3d93cb.js"><link rel="prefetch" href="/note/assets/js/27.bc13d84b.js"><link rel="prefetch" href="/note/assets/js/28.b07d4db5.js"><link rel="prefetch" href="/note/assets/js/3.103e303a.js"><link rel="prefetch" href="/note/assets/js/4.4b102e12.js"><link rel="prefetch" href="/note/assets/js/5.655ceffb.js"><link rel="prefetch" href="/note/assets/js/6.477f0112.js"><link rel="prefetch" href="/note/assets/js/8.ddb22616.js"><link rel="prefetch" href="/note/assets/js/9.0a1e0ae9.js">
    <link rel="stylesheet" href="/note/assets/css/0.styles.27c4b003.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note/" class="home-link router-link-active"><img src="/note/img/emoji.png" alt="Jtf‘s Note" class="logo"> <span class="site-name can-hide">Jtf‘s Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="目录" class="dropdown-title"><span class="title">目录</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          日记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/diary/2021/" class="nav-link">
  2021
</a></li></ul></li><li class="dropdown-item"><h4>
          学习
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/study/sociology/" class="nav-link">
  社会学
</a></li></ul></li><li class="dropdown-item"><h4>
          编程
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/biancheng/swift/" class="nav-link">
  Swift
</a></li><li class="dropdown-subitem"><a href="/note/biancheng/python/" class="nav-link router-link-exact-active router-link-active">
  Python
</a></li><li class="dropdown-subitem"><a href="/note/biancheng/raspberry/" class="nav-link">
  树莓派
</a></li><li class="dropdown-subitem"><a href="/note/biancheng/git/" class="nav-link">
  Git笔记
</a></li></ul></li><li class="dropdown-item"><h4>
          读书
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/read/booklist/" class="nav-link">
  书单
</a></li></ul></li><li class="dropdown-item"><h4>
          计划
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/plan/kaoyan/" class="nav-link">
  考研
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://jtf.im/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/thejtf/note" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="目录" class="dropdown-title"><span class="title">目录</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          日记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/diary/2021/" class="nav-link">
  2021
</a></li></ul></li><li class="dropdown-item"><h4>
          学习
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/study/sociology/" class="nav-link">
  社会学
</a></li></ul></li><li class="dropdown-item"><h4>
          编程
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/biancheng/swift/" class="nav-link">
  Swift
</a></li><li class="dropdown-subitem"><a href="/note/biancheng/python/" class="nav-link router-link-exact-active router-link-active">
  Python
</a></li><li class="dropdown-subitem"><a href="/note/biancheng/raspberry/" class="nav-link">
  树莓派
</a></li><li class="dropdown-subitem"><a href="/note/biancheng/git/" class="nav-link">
  Git笔记
</a></li></ul></li><li class="dropdown-item"><h4>
          读书
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/read/booklist/" class="nav-link">
  书单
</a></li></ul></li><li class="dropdown-item"><h4>
          计划
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/plan/kaoyan/" class="nav-link">
  考研
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://jtf.im/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/thejtf/note" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/biancheng/python/#笔记" class="sidebar-link">笔记</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/note/biancheng/python/#方括号创建列表、圆括号创建元组" class="sidebar-link">方括号创建列表、圆括号创建元组</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/note/biancheng/python/#list-关键字创建列表，tuple-创建元组" class="sidebar-link">list 关键字创建列表，tuple 创建元组</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/note/biancheng/python/#使用花括号加键值对创建字典" class="sidebar-link">使用花括号加键值对创建字典</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/note/biancheng/python/#使用-dict-关键字创建字典" class="sidebar-link">使用 dict 关键字创建字典</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="笔记"><a href="#笔记" class="header-anchor">#</a> 笔记</h2> <p>根据 Python 官方文档，数据类型和容器其实都统称为「数据类型」，但是为了能让读者便于理解和区分，我还是将其拆为两部分。</p> <p>如果你对现在主流的编程语言有过了解，那么你就会发现这些语言存在一些共同点，其中必不可少的就是数据类型和容器。</p> <p>所谓的数据类型和容器其实在理解上很直接，前者表示对应的类型而后者好似器皿可以容纳东西。因此，通常对于数据类型往往是针对单个值而言的，而容器则是容纳多个单值（类型可能相同，也可能不同）的器皿。</p> <p>首先说说数据类型。为什么要强调数据类型，那是因为这是要和计算机「约法三章」。举个例子：</p> <p>1+1 #第一种
'1+1' #第二种
以上对于 1+1 的表示方法其实分别代表了不同的数据类型。第一种表示的就是我们数学上的数值 1+1 的概念；第二种如果让人来理解其实也就是数学上的 1+1，但是如果让计算机来理解，不好意思，这不是数值 1+1 ，而是一个字符串（String），就表示 '1+1' 这个文本。</p> <p>所以在计算机程序的世界里，它只会理解符合它被预先设定的某些编码（Codes），仍不能做到像人一样很聪明地去理解不同的表示方法。因此我们在编程时，就需要事先声明（Statement）某个代码它的类型是什么，然后通过编译器将代码转换成计算机能理解的形式并被计算机执行。</p> <p>但好在很多语言都有自动类型推断机制，比如 Scala、Go 等，Python 本身也具备这样的功能，所以它能聪明地帮我们将输入的每个数字或字符在底层指定成相应的类型，因此上面的例子其实就等价于下面的情况：</p> <p>a = 1+1 #数值
b = '1+1' #字符串
然而在其他一些编译型语言中，如 Java 语言，我们必须要事先指定类型，才能保证编译通过：</p> <p>int a = 11;
String b = &quot;1+1&quot;;
在这里 int 表示整型（Integer），其实就是我们小学学的整数概念；而 String 就是表示字符串类型。</p> <p>接下来聊聊容器。</p> <p>容器的概念其实比数据类型更好理解一些，在现实世界中，我们可以找到无数个容器的实物，比如杯子、脸盆、饭锅等，其实都属于可以用来「装东西」的容器。所以在编程语言里容器的作用也和现实世界中的作用相一致，它可以用来存放许多不同数据类型的东西。</p> <p>比如 Python 中的 list 列表就是容器的一种，我们可以用它来存储许多的数值或字符串甚至是另一种容器：</p> <blockquote><blockquote><blockquote><p>myList = [1+1, '1+1', [1,2,3,4,5]]
print(myList)
[2, '1+1', [1, 2, 3, 4, 5]]
除了列表之外，在 Python 中还有元组、字典、集合等，这些常见的容器可能也会以不同的表现形式出现在其他编程语言之中，但它们本质上都是殊途同归的。</p></blockquote></blockquote></blockquote> <ol start="2"><li>Python 中的常用数据类型
Python 中的基本数据类型主要有以下几类：</li></ol> <p>整型（int）
浮点型（float）
复数（complex）
布尔值（bool）
其中整型、浮点型和复数都属于数值型，而布尔值仅表示 false 和true 这两类值的类型。我们可以使用 Python 中内置的 type() 函数来查看某个值属于什么类型。</p> <p>整型在上一节中我们有提到过，其实就是我们小学数学课上的的整数，包括正整数和负整数，总而言之就是不带任何小数点的数都属于整数。</p> <blockquote><blockquote><blockquote><p>type(1+1) #int
&lt;class 'int'&gt;
浮点型其实就带小数的数值，只要在数值后带有小数点，就属于浮点型。</p></blockquote></blockquote></blockquote> <blockquote><blockquote><blockquote><p>type(1.0) #float
&lt;class 'float'&gt;</p></blockquote></blockquote> <blockquote><blockquote><p>type(3.14159267) #float
&lt;class 'float'&gt;
这里我们可以看到尽管 1.0 在人看来其实就是数值 1，但是在计算机看来其实和整数 1 其实还是有所不同的。</p></blockquote></blockquote></blockquote> <p>复数就是高中我们学习的复数概念，要是没有了解过这个概念也没关系，因为如果不是做有关科学计算或者数学计算，通常来说这种类型使用较少：</p> <blockquote><blockquote><blockquote><p>type(1+4j) #complex
&lt;class 'complex'&gt;
布尔值其实就是和物理学中的一些物理量，如牛顿（N）、瓦特（W）一样是根据某个人来命名，这个人叫乔治·布尔，因为他首先定义了代数逻辑系统（见 维基百科介绍）。</p></blockquote></blockquote></blockquote> <blockquote><blockquote><blockquote><p>type(True) #bool
&lt;class 'bool'&gt;</p></blockquote></blockquote> <blockquote><blockquote><p>type(False) #bool
&lt;class 'bool'&gt;
通常来说，布尔值就只有两种情况：0 或 1。但我们要回想中学数学学过的一些逻辑命题，我们应该都有做过类似判断命题真假的题目。</p></blockquote></blockquote></blockquote> <p>所以我们就有了 真（True）=1、假（False）=0 这样的关联，真与假其实也可以延申为是与否、成立与不成立。因此从布尔值的逻辑判断情况就成了 是（成立、真）=1，而它的相反情况就是 否（不成立、假）=0</p> <p>在 Python 中尽管我们需要以 True 或False 来表达布尔值，但是在后面的控制条件章节中，其实就可以直接以整数 1 或 0 来代表真与假两种条件。</p> <ol start="3"><li>Python 中的常用数据容器
在 Python 中的容器类型有很多，比如：</li></ol> <p>序列类型：列表（list）、元组（tuple）
文本序列类型：字符串（str）
二进制序列类型：字节（Bytes）
集合类型：集合（set）
映射类型：字典（dict）
以上是我简单列举的常见的容器类型，当然我们主要涉及的是序列类型、文本序列类型、集合类型和映射类型四种。其中有关于文本序列类型的字符串类型会在后面单独成篇，本节就不过多涉及。</p> <p>3.1 序列类型：列表、元组
3.1.1 创建
列表（list）和元组（tuple）在表现形式上十分类似，但是创建形式会有所区别。</p> <p>我们都可以分别用不同类型的括号和关键字来创建：</p> <h2 id="方括号创建列表、圆括号创建元组"><a href="#方括号创建列表、圆括号创建元组" class="header-anchor">#</a> 方括号创建列表、圆括号创建元组</h2> <p>myList1 = [1,2,3,4]
myTuple1 = (1,2,3,4)</p> <h2 id="list-关键字创建列表，tuple-创建元组"><a href="#list-关键字创建列表，tuple-创建元组" class="header-anchor">#</a> list 关键字创建列表，tuple 创建元组</h2> <p>myList2 = list('abcde')
myTuple2 = tuple('abcde')
可以看到列表和元组在创建和表现形式上都十分相似，但二者的区别在于：是否可以修改。其中列表是可修改，而元组则不能。因此列表是实际中最常使用的容器类型。</p> <p>而使用关键字来创建往往是将某个容器类型转换成另外一种容器类型时才会使用到关键字，通常情况下我们通过对应的符号来创建即可。</p> <p>所以为了便于行文，我就围绕列表展开。</p> <p>3.1.2 索引切片
索引和切片其实是从数据容器中提取数据的两个动作或者是过程。</p> <p>索引你可以理解成是电影票上的座位号，它对应的是点；那么切片顾名思义也就是一片、一块，对应的是段。</p> <p>在 Python 中，无论是遍历（后面我们会讲到）、索引、切片，都是从「0」开始。这可能与我们在数数（shǔshù）时的认知有点相悖，但是只要记住「从零开始」这句话即可。</p> <p>假设医生给了我一盒药，里面有五颗药丸，每颗药丸都带有标签分别是 「one」、「two」、「three」、「four」、「five」，分别对应示意图里的 A、B、C、D、E。</p> <blockquote><blockquote><blockquote><p>box = ['one', 'two', 'three', 'four', 'five']
那么他们在药盒子中对应的位置就是 0-4。</p></blockquote></blockquote></blockquote> <p>思考：从 0 到 3 有几个整数？</p> <p>此时，今天如果我要吃药丸「one」。那么需要将其从中拿出，通过示意图我们可以知道，列表中的元素位置都是固定的。刚好药丸「one」又在第一个，那我这时从中取出就应该是「索引」：</p> <blockquote><blockquote><blockquote><p>box[0]
'one'
但是医生说，我不能只吃一粒，要吃三粒，那么我就应该用上「切片」：</p></blockquote></blockquote></blockquote> <blockquote><blockquote><blockquote><p>box[0:3] #显示 one、two、three
['one', 'two', 'three']
回到我前面说的那个思考题，0 到 3 一共有几个整数呢？</p></blockquote></blockquote></blockquote> <p>答案是 4 个。可按理来说我们用 box[0:3] 应该是把前 4 个药丸都拿出来了，可是为什么只显示 3 个呢？</p> <p>那是因为切片遵循着左闭右开的数学法则。回想一下我们在中学数学的课本里学过「区间」这一概念，这里我就用数学上的集合图给你表示一下就清楚了。</p> <p>所以在这里我们使用 box[0:3] 其实就是相当于数学上区间 ([0,3))。由于在索引 3 上取不到，所以只能取 0、1、2 三个点上的数据。这就是切片用法 。</p> <p>思考：我如何切片才能够囊括药丸「four」？</p> <p>3.1.3 列表和元组方法
列表和元组的操作方法也大致类似，只不过由于元组属于不可变序列，因此能够使用的方法较列表少一些，即列表能用的方法元组不一定能用，元组能用的方法列表一定可以用。</p> <p>这里主要涉及几个方法：</p> <p>增：append、extend
删：remove、pop
查：index
我们通过一个小例子来进行所有操作，首先我们先建立一个购物清单列表 apple，在列表中我存入了一些数据。</p> <blockquote><blockquote><blockquote><p>apple = ['iPhone', 'iPad', 'MacBook', 'Apple Watch',
...          'Mac Pro', 'iMac', 'Mac mini', 'iMac Pro']</p></blockquote></blockquote> <blockquote><blockquote><p>apple.append('iPod') # 1
apple.extend(['iPhone 11 Pro']) #2
apple.remove('iMac Pro') #3
apple.pop() #默认弹出最后一个 #4
'iPhone 11 Pro'</p></blockquote></blockquote> <blockquote><blockquote><p>apple.pop(2) #弹出第3个元素
'MacBook'</p></blockquote></blockquote> <blockquote><blockquote><p>apple.index('Mac mini') #5
5
以上操作详解如下：</p></blockquote></blockquote></blockquote> <p>使用 append() 方法将 iPod 追加到 apple 这个列表中
使用 extend() 方法将 iPhone 11 Pro 扩展到 apple 这个列表中
使用 remove() 方法将 iMac Pro 从 apple 列表中移除
使用 pop() 方法弹出 apple 列表中的项目，不指定索引数时是默认弹出最后一个元素，使用 pop(2) 则是弹出第三个元素 MacBook
使用 index()方法来查看元素在列表中的位置，apple.index('Mac mini') 即返回 apple 列表中 Mac mini 的索引数
3.2 映射序列类型：字典
字典是 Python 内置的容器中比较灵活的一种，也是常用的数据结构之一，字典你可以看做是列表的进阶版。</p> <p>顾名思义，你可以将字典近似理解成我们小学上语文课用到的「中华字典」。尽管形式上可能会有点差异，但是本质十分相近。</p> <p>3.2.1 键值对
说字典灵活是因为它可以将列表、甚至自身的字典类型容纳进去。但无论容纳的东西有多少，都只用唯一一个「键」（key）来关联。</p> <p>字典示意图
字典示意图
所以要理解字典，就需要先对「键-值」对的形式有所认识。所谓的「键-值」对就是在字典中每一个键对应着一个值，这个值可以是单值也可以是个容器，但这些值对应的有且仅有一个键。</p> <p>形象理解就是：每个人都只会有唯一的一个公民身份证号，在这个身份证号之下关联着我们许许多多的个人信息。</p> <p>比如我现在有以下这么一个字典：</p> <blockquote><blockquote><blockquote><p>info = {
...     'name': '100gle',
...     'personal_info': {
...         'slogen': '自律即自由',
...         'gender': 'male'
...     },
...     100: 'Hello, world!',
...     100: 'Hello, sspai!',
...     'money': [1000, 10000, 100000]
... }
最后结果则是这样的：</p></blockquote></blockquote></blockquote> <blockquote><blockquote><blockquote><p>from pprint import pprint
pprint(info)
{100: 'Hello, sspai!',
'money': [1000, 10000, 100000],
'name': '100gle',
'personal_info': {'gender': 'male', 'slogen': '自律即自由'}}
通过我这个 info 字典我们可以的字典的一些特性：</p></blockquote></blockquote></blockquote> <p>可以容纳自身字典类型。info['personal_info'] 本身又是一个字典
键（Key）是唯一的。info 中的两个 100 的键，只有最后一个被保留了下来
可包含的数据类型包括字符串、数值、列表等。
键可以是字符串也可以是数字
所以你可以从这当中看出字典的灵活性，而且具有很清晰的结构性。</p> <p>3.2.2 创建
创建字典和集合与创建列表和元组一样，都可以通过不同的括号和关键字来进行创建。</p> <h2 id="使用花括号加键值对创建字典"><a href="#使用花括号加键值对创建字典" class="header-anchor">#</a> 使用花括号加键值对创建字典</h2> <blockquote><blockquote><blockquote><p>myDict1 = {&quot;host&quot;: &quot;sspai&quot;} #字典</p></blockquote></blockquote></blockquote> <h2 id="使用-dict-关键字创建字典"><a href="#使用-dict-关键字创建字典" class="header-anchor">#</a> 使用 dict 关键字创建字典</h2> <blockquote><blockquote><blockquote><p>myDict2 = dict(host=&quot;sspai&quot;)
3.2.3 索引
由于键值对的特性，所以字典就不能像列表那样可以直接切片获得数据。因此如果你要从字典中获取数据，就只能通过索引来获取键下面对应的值。</p></blockquote></blockquote></blockquote> <blockquote><blockquote><blockquote><p>info['name'] #返回 100gle
'100gle'</p></blockquote></blockquote> <blockquote><blockquote><p>info[100] #返回 Hello, sspai!
'Hello, sspai!'
3.2.4 字典方法
字典的方法也有很多，这里主要介绍常用的几个。首先我们还是新建一个示例数据info</p></blockquote></blockquote></blockquote> <blockquote><blockquote><blockquote><p>info = {
...     'name': '100gle',
...     'telephone': '021-XXXX-XXXX',
...     'gender': 'male',
...     'email': 'xiaoyue.lin@outlook.com'
... }</p></blockquote></blockquote> <blockquote><blockquote><p>info.keys() #1
dict_keys(['name', 'telephone', 'gender', 'email'])</p></blockquote></blockquote> <blockquote><blockquote><p>info.values() #2
dict_values(['100gle', '021-XXXX-XXXX', 'male', 'xiaoyue.lin@outlook.com'])</p></blockquote></blockquote> <blockquote><blockquote><p>info2 = dict(id=0) #3
info.update(info2) #3
print(info)
{'name': '100gle', 'telephone': '021-XXXX-XXXX', 'gender': 'male', 'email': 'xiaoyue.lin@outlook.com', 'id': 0}
以上操作详解如下：</p></blockquote></blockquote></blockquote> <p>使用 keys() 方法来获取字典中的所有键（key）
使用 values() 方法来获取字典中所有的值（value）
新建一个字典 info2，然后使用 update() 方法将 info2 中的数据更新到 info 中。
3.3 集合序列类型：集合
集合在外形上和字典也十分类似，都是用花括号来表示。</p> <p>集合就是数学中的集合概念，它虽然也像元组那样有所限制，但是它的适用场景可比元组要好得多。</p> <p>集合实际上也还是我们中学时候学过的集合概念，但是它实际的功能是起着「交集」的作用。</p> <p>在示意图中可以很清楚地知道，A 和 B 相交得到的数字集就是集合。</p> <p>3.3.1 创建
我们可以通过 {} 花括号和 set() 关键字来进行创建集合。要注意的是，在使用花括号时，没有传入键值对而是传入值创建的才是集合，否则创建的是字典。</p> <blockquote><blockquote><blockquote><p>a = {}
type(a)
&lt;class 'dict'&gt;</p></blockquote></blockquote> <blockquote><blockquote><p>b = {1,2}
type(b)
&lt;class 'set'&gt;
3.3.2 集合方法
集合的概念由于和数学上集合的概念相一致，所以集合的一系列方法最主要也是围绕着集合与集合间的操作进行。</p></blockquote></blockquote></blockquote> <blockquote><blockquote><blockquote><p>set1 = {'apple', 'google', 'microsoft'}
set2 = {'apple', 'huawei', 'oneplus'}
set1.add('Amazon') #1
set1.intersection(set2) #2
{'apple'}</p></blockquote></blockquote> <blockquote><blockquote><p>set1.union(set2) #3
{'google', 'oneplus', 'apple', 'Amazon', 'microsoft', 'huawei'}</p></blockquote></blockquote> <blockquote><blockquote><p>set1.difference(set2) #4
{'google', 'Amazon', 'microsoft'}
以上操作详解如下：</p></blockquote></blockquote></blockquote> <p>向 set1 集合中添加元素 Amazon
求 set1 集合和 set2 集合的交集
求 set1 集合和 set2 集合的并集
求 set1 集合和 set2 集合的差集
用一张图来概括上面三种情况或许会更清楚一些：</p> <p>交、并、差
相比于元组来说，集合的方法更多，并且也更具实用性。</p> <ol start="4"><li>实践案例：API 调用
作为一个学习者，在学习的过程中，除了具备自我学习的能力外，还应该能善于利用现有的资源来助力自身，这样才能算是优秀的学习者。</li></ol> <p>所以本章我们主要去通过调用其他平台免费提供的第三方 API 接口来实现某些功能，如 OCR（光学字符识别）、文字转语音等。本次我们用 百度 AI 开放平台 的 API 进行实践，让大家也体验一次开发者的历程。除了百度之外，像高德、华为等互联网大厂，只要涉及到 API 之类的开发也都会提供相应的接口，因此本次实践完后再去使用其他平台的接口相信也难不倒我们。</p> <p>4.1 API 应用申请
在使用其他平台的 API 之前，基本上毫无例外都要先注册并创建一个应用。打开百度 AI 开放平台的页面后，点击右上角控制台进行登录（没有注册账号的需要注册）。</p> <p>百度 AI 开放平台
百度 AI 开放平台
进入到控制台之后我们就可以在左侧看到平台能提供的服务种类有很多，所以根据需要我们可以进入到不同接口的页面。这里我们就进入「文字识别」里就可以看到有关于该服务下的所有列表。</p> <p>对于我们个人而言，每天的免费调用次数完全已经能够满足个人的使用需求。因此我们进一步点击创建应用。</p> <p>在默认位置填入相应信息之后，我们就可以直接创建一个应用。创建完成点击查看应用详情，在这里我们只需要看最上面的一栏，当中包括了「AppID」、「API Key」、「Secret Key」等几项。其中这三项是我们能够调用接口的「身份证」。因此在使用的时候要将其传入。</p> <p>创建好应用之后，我们就接着点击左侧的「SDK 下载」去下载配套的开发套件。所谓的 SDK 就是 Software Development Kit（软件开发工具包），这是平台为我们搭建好的一个开发框架，我们只需要调用即可，不需要自己额外搭建。这里要夸一夸百度，提供的 SDK 下载很丰富，而且从注册账号到创建应用的过程简单、直观，比华为云好太多太多。</p> <p>我们找到 Python 的 SDK 之后进行下载，当然如果你觉得麻烦想一步到位那么也可以直接用pip install baidu-aip 进行安装。</p> <p>除此之外我们还要打开 SDK 旁边对应使用说明。使用说明就相当于我们购买产品时附赠的说明书，上面有一切能够让你快速上手的介绍。由于平台提供的SDK不像其他第三方库一样有着详细的教程，所以在使用对应平台的API时就只有这一份说明文档仅供我们参考。</p> <p>4.2 HTTP 请求与返回
在进入到实践环节之前，我们还要稍微了解一下有关于 HTTP 请求的几种方式以及返回结果。</p> <p>所谓的 HTTP 就是「HyperText Transfer Protocol」（超文本传输协议）的简写，通过这种协议我们才能通过服务器来获取各种信息数据，这也就是为什么我们打开一个网站时要输入网址，然后页面会呈现一些内容的原因。</p> <p>以少数派网站为例子，我们用 Chrome 浏览器登录到少数派官网，然后按下 F12 的开发者工具，然后跳转到 Networks 选项卡中，再刷新一次我们就可以看到随着页面的加载，同样会有很多资源不断地出现。</p> <p>点击其中一个资源，再点击相应的 headers 选项，我们就可以看到该资源请求的相关信息了。</p> <p>4.2.1 HTTP 请求方法
通常来说，HTTP请求的方式或者说方法包括但不限于以下几种：</p> <p>GET
POST
PUT
DELETE
PATCH
其中 GET 和 POST 方法最为常用。当然仅从单词的意思上我们就可以区分两者 GET 方法主要是用于向服务器获取数据，POST 方法则是向服务器提交或传递数据。</p> <p>所以在调用接口时我们需要看一看开发文档的对于接口的请求说明，才能知道我们要以怎样提交我们的查询数据。</p> <p>不过好在百度 AI 开放平台的接口的 SDK 已经为我们铺好这条路，我们只需要考虑提交的数据即可，就不需要考虑是以什么方式发送请求。但是在调用其他平台的接口时还是要阅读开发文档了解是以怎样的方式发送请求，否则可能会出错。</p> <p>4.2.2 请求返回
在说明文档中与请求方法一起列出的就是返回结果，当中包含了请求结果的状态码以及其他信息，各个平台返回的结果可能不一样，这里就不一一细说，查阅相关开发文档即可。</p> <p>目前通过 Web 请求得到的返回结果大多数是以 JSON 呈现。JSON 格式从外形上来理解就是「多层嵌套的字典」，也是现今较为流行的一种交换数据的格式。</p> <p>虽然说 JSON 格式数据不是 Python 内置的标准数据容器，但是也提供了相应的 json 库用来专门处理这类数据并转化成我们熟悉的字典形式，等遇上的时候我们再谈具体细节。</p> <p>一切就绪之后我们就可以进入到实践环节了。</p> <p>4.3 OCR 识别
现在各种 OCR 应用或小程序有很多，如白描、天若 OCR 等，但总的来说核心功能无外乎就是将图片上的字符进行识别最后转换成文字。完成了前面的步骤之后，现在你也可以尝试调用百度 API 的接口，做一次自己的 OCR 识别。</p> <p>在使用百度的 API 接口前，我们需要创建一个身份认证的对象，你可以简单理解为我们登录调用接口的一个账号。</p> <p>这个账号的相关信息就是我们前面提到的在自己应用中的重要三项，即「AppID」、「API Key」、「Secret Key」这三项。根据百度的开发文档，我们使用 AipOcr 接口来实例化：</p> <p>from aip import AipOcr #1</p> <p>&quot;&quot;&quot; 替换成你的应用中的 APPID AK SK &quot;&quot;&quot;
APP_ID = '<strong><strong><strong><strong>' #2
API_KEY = '</strong></strong></strong></strong><strong><strong><strong><strong><strong><strong><strong><strong>' #3
SECRET_KEY = '</strong></strong></strong></strong></strong></strong></strong></strong>****************' #4
client = AipOcr(APP_ID, API_KEY, SECRET_KEY) #5
以上操作详解：</p> <p>从百度的 aip 中导入 AipOcr 接口
创建调用接口所需的 APP_ID 字符串变量
创建调用接口所需的 API_KEY 字符串变量
创建调用接口所需的 SECRET_KEY 字符串变量
将创建好的字符串参数传入接口 AipOcr 中并创建一个操作对象 client
创建好登录对象之后我们就可以调用相关接口的实例方法。在这里我们还额外导入两个库用于辅助，一个是 pprint 库，它能将返回的 JSON 数据以层次分明的形式输出打印；还有一个就是我之前提到的 pandas 库，它当中提供的 json_normalize 函数特别好用，可以将 JSON 格式数据转换成结构化的数据。</p> <p>from pprint import pprint #1
from pandas.io.json import json_normalize #2
以上操作详解：</p> <p>从内置的 pprint 库中导入 pprint() 函数
从第三方Pandas 库中的 io.json 模块下导入 json_normalize
现在我们定义一个读取的函数，方便我们调用。为了能够将图片读入 Python 环境中，我们需要通过 with..open 的语句将待识别的图片以 rb 二进制的方式读入。因为我们传入的数据要以按开发文档的参数要求来，所以直接拿官方参考例子进行稍微修改即可。</p> <p>这里就拿我买的东芝硬盘附赠的说明书图片进行测试，图片样例如下：</p> <p>def get_file_content(filePath): #1
with open(filePath, 'rb') as fp: #2
return fp.read() #3
image = get_file_content(r'material/02-baidu-api/desc.jpeg') #4
以上操作详解：</p> <p>定义一个名为get_file_content的函数，其参数为filePath 文件路径
在这个函数之下使用with open():的语句打开指定路径的文件，其中rb 表示read（只读）和binary（二进制形式）
最后用return语句返回使用read() 读取后的文件
调用定义好的get_file_content读取待识别图片，并将其赋值给image变量。
当然有兴趣的朋友可以打印一下看看image包含了什么东西，但是我并不建议这样做，因为一张图片经过二进制方式读入内容会十分庞杂，我们可以输出它的长度看看：</p> <p>len(image) #返回168646 #1
以上操作详解：</p> <p>使用内置的len()函数返回图像长度
完事具备之后我们就可以将参数传入某个接口了。这里我们就调用基础的通用文字识别接口然后再用pprint() 输出一下返回的结果：</p> <blockquote><blockquote><blockquote><p>result = client.basicGeneral(image)# 1
pprint(result) # 2
{'log_id': 3135391163860111749,
'words_result': [{'words': '您的权利'},
{'words': '某些州或省不允许排除或限制偶发性或后果性损失,所以上述限制或除外'},
{'words': '条款可能不适用您。此保固声明赋予您特定的法律权利,并且您可能拥有各'},
⋯⋯
{'words': '回的产品不包含受制于美国或您所在国出口管制的任何软件或技术。'},
{'words': '地理覆盖范围'},
{'words': '请访问URL以在线查看。tp:/www.toshiba-personalstorage.net/en/'},
{'words': 'support/download/hdd/ot_ idd/gc. htm)'},
{'words': '3'}],
'words_result_num': 24}
以上操作详情：</p></blockquote></blockquote></blockquote> <p>调用前面创建好的client接口下的basicGeneral 通用识别接口，并将读取的待识别图片上传并将识别的结果赋值给result 变量
使用pprint() 函数美化输出并打印result 变量。
可以看出，输出的结果并不是我们预想那样格式规整地返回给我们，毕竟 OCR 目前只是识别文字，但是对于格式可能就没有那么高的精度；所以从识别的准确率来说已经是十分可观了。</p> <p>到这一步来说还不算结束，因为我们虽然获取到了返回的识别结果，但是它仍然还是躺在 JSON数据格式中；所以就需要进一步将其结构化，这时json_normalize() 方法就排上用场了。这里我们从返回结果中的words_result进行结构化。</p> <p>text = json_normalize(result['words_result']) #1
以上操作详解：</p> <p>使用json_normalize() 方法对result 字典中的words_result 这一键下的值进行提取
接着我们再稍微text.head()输出一下前 5 个数据看看：</p> <div class="language- extra-class"><pre><code>                           words
</code></pre></div><p>0                               您的权利
1   某些州或省不允许排除或限制偶发性或后果性损失,所以上述限制或除外
2  条款可能不适用您。此保固声明赋予您特定的法律权利,并且您可能拥有各
3  州或各省互不相同的其他权利。如果适用法律不允许限制或排除,则此保固
4   声明会被认为在一定程度上允许修改,但是此保固声明的其他部分仍有效
由于经过json_normalize()转换后的text已经是DataFrame 类型，导出方法直接将其导出成.csv 格式或.txt。</p> <p>text.to_csv(r'/Users/linxiaoyue/Desktop/rslt.txt', index=False,
encoding='utf-8-sig')
到这里我们也可以看到，当图片较为清晰、规整时，识别的准确率就会大幅度提高；但是如果当图片有所畸变或是并不规整时，识别的准确率可能就会有所降低并且结果与我们想要的也是相去甚远。当然处理这些不「正常」的情况所需要技术和精力时间会更多。</p> <p>但是就目前的百度 API 接口来说，对于我们日常的一些识别需求已经是完全够用了。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/thejtf/note/edit/master/docs/biancheng/python/README.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">1/5/2021, 7:31:58 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/note/assets/js/app.105f0ca5.js" defer></script><script src="/note/assets/js/2.780ff301.js" defer></script><script src="/note/assets/js/7.e74d6790.js" defer></script>
  </body>
</html>
